# 复杂链表的复制
## 题目描述
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
## 解题思路
### 1、设计对应节点的键值对，以空间换时间，时间效率为O(n)，空间效率为O(n)
```

```
### 2、利用上一步的思想，先将所有节点复制，将每一个节点的复制插入到原节点的后边，对于特殊指针则指向对应的节点的复制节点，可以实现对于特殊指针的查找效率为O(1)，最后将链表进行拆分，返回复制出的节点
```
# -*- coding:utf-8 -*-
# class RandomListNode:
#     def __init__(self, x):
#         self.label = x
#         self.next = None
#         self.random = None
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):                        #Main
        # write code here
        if pHead == None:
            return None
        self.add(pHead)
        self.addrandom(pHead)
        return self.spilt(pHead)
    def add(self,pHead):                               #在原节点后增加其复制节点
        Head = pHead
        while Head:
            pclone = RandomListNode(Head.label)        #注：此处必须定义类的实例
            pclone.next = Head.next
            pclone.random = None
            Head.next = pclone
            Head = pclone.next
    def addrandom(self,pHead):                         #为复制节点增加特殊指针
        Head = pHead
        while Head:
            pclone = Head.next
            if Head.random != None:
                pclone.random = Head.random
            Head = pclone.next
    def spilt(self,pHead):                         #此处为分离原链表与复制链表，并返回复制的链表
        Head = pHead
        cloneHead = Head.next
        while Head.next != None:
            pclone = Head.next
            Head.next = pclone.next
            Head = pclone
        return cloneHead
```
